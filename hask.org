* Chapter 1
  Î»: expressions, variables, and abstractions

  Expression can be a variable name, an abstractions, or a combination of those things.

  Variables have no meaning or value; placeholders for inputs.

  An abstraction is a function. It is a lambda term that has a
  head (a lambda) and a body and is applied to an argument. An
  argument is an input value.

  The head of the function is a Î» (lambda) followed by a variable
  name. The body of the function is another expression. So, a
  simple function might look like this:

  Î»ð‘¦.ð‘¦

  Î» x . x
  ^â”€â”¬â”€^
    â””â”€â”€â”€â”€â”€â”€ extent of the head of the lambda.

  Î» x . x
    ^â”€â”€â”€â”€â”€â”€ the single parameter of the
            function. This binds any
            variables with the same name
            in the body of the function.

  Î» x . x
        ^â”€â”€ body, the expression the lambda
            returns when applied. This is a
            bound variable.


  The dot (.) separates the parameters of the lambda from
  the function body.

** Beta reduction
   Letâ€™s use the function we had above:
   Î»ð‘¦.ð‘¦

   Weâ€™ll do our first beta reduction using a number.2 We apply
   the function above to 2, substitute 2 for each bound variable
   in the body of the function, and eliminate the head:
   (Î»ð‘¦.ð‘¦) 2

   Letâ€™s use an example that mixes some arithmetic into our
   lambda calculus. We use the parentheses here to clarify that
   the body expression is ð‘¦+1. In other words, we are not applying
   the function to the 1:
   (Î»ð‘¦.ð‘¦ + 1)

   (Î»x.x)(Î»y.y)
   [x := (Î»y.y)] Indicate thath (Î»y.y) will be substituted for all occorrences of x.
           Î»y.y

   (Î»x.x)(Î»y.y)z

   its the same as : ((Î»x.x)(Î»y.y))z

   reduction:

   ((Î»x.x)(Î»y.y))z
   [x := (Î»y.y)]
   (Î»y.y)z
   [y := z]
         z

   Î»x.xy

   The whole abstraction can be applied to an agrument z
   1. (Î»x.xy)z
   2. (Î»[x := z].xy)
   3. zy


   "multiple" argument lambda:
   1. Î»xy.xy
   2. (Î»xy.xy) 1 2
   3. (Î»x.(Î»y.xy)) 1 2
   4. [x âˆ¶= 1]
   5. (Î»y.1y) 2
   6. [y âˆ¶= 2]
   7. 1 2

   Another one:
   1. Î»xy.xy
   2. (Î»xy.xy)(Î»z.a) 1
   3. (Î»x.(Î»y.xy)(Î»z.a)1
   4. [x := (Î»z.a)]
   5. (Î»y.(Î»z.a)y) 1
   6. [y := 1]
   7. (Î»z.a) 1
   8. [z := 1] But there is no z in the body of the functions, so we eliminate the head
   and the result is 'a'.
   9. a


   Another one:
   1. (Î»xyz.xz(yz))(Î»mn.m)(Î»p.p)

   2. (Î»x.Î»y.Î»z.xz(yz))(Î»m.Î»n.m)(Î»p.p)
      We've not reduces or applied anything here, but made the currying explicit.

   3. (Î»y.Î»z.(Î»m.Î»n.m)z(yz))(Î»p.p)
      Our first reduction step was to apply the outermost lambda,
      which was binding the x, to the first argument, (Î»m.Î»n.m).

   4. (Î»z.(Î»m.Î»n.m)(z)((Î»p.p)z))
      We applied the y and replaced the single occurrence of y with the next argument,
      the term (Î»p.p). The outermost lambda binding z is, at this point, irreducible
      because it has no argument to apply to. What remains is to go inside the terms
      one layer at a time until we find something reducible.

   5. Î»z.(Î»n.z)((Î»p.p)z)
      We can apply the lambda binding m to the argument z. The next thing we can apply is
      the lambda binding n to the lambda term ((Î»p.p)z).

   6. Î»z.z
      In the final step, the reduction takes a turn that might look
      slightly odd. Here the outermost, leftmost reducible term
      is Î»n.z applied to the entirety of ((Î»p.p)z). As we saw in
      an example above, it doesnâ€™t matter what ð‘œ got bound to,
      Î»n.z unconditionally tosses the argument and returns z.
      So, we are left with an irreducible lambda expression.



** Combinators

   A combinator is a lambda term with no free variables. Combi-
   nators, as the name suggests, serve only to combine the argu-

   When every term in the body occours in the head:

   1. Î»x.x
   2. Î»xy.x
   3. Î»xyz.xz(yz)

   And the following are not combinators because there's one or more free variables

   1. Î»y.x --- x is free
   2. Î»x.xz --- z is free



** Divergence

   Not all reducible lambda terms reduce neatly to a beta normal
   form. This isnâ€™t because theyâ€™re already fully reduced, but
   rather because they diverge. Divergence here means that the
   reduction process never terminates or ends. Reducing terms
   should ordinarily converge to beta normal form, and diver-
   gence is the opposite of convergence, or normal form. Hereâ€™s
   an example of a lambda term called omega that diverges:

   1. (Î»x.xx)(Î»x.xx)
      x in the first lambdaâ€™s head becomes the second lambda

   2. ([x := (Î»x.xx)]xx)
      Using [var := expr] to denote what x has been bound to.

   3. (Î»x.xx)(Î»x.xx)
      Substituting (Î»x.xx) for each occurence of x. We're back to where
      we started and this redution process never ends
      - we can say omega diverges.

   This matters in programming because terms that diverge
   are terms that donâ€™t produce an answer or meaningful result.
   Understanding what will terminate means understanding what
   programs will do useful work and return the answer we want.


** Summary

   The main points you should take away from this chapter are:
   â€¢ Functional programming is based on expressions that in-
   clude variables or constant values, expressions combined
   with other expressions, and functions.

   â€¢ Functions have a head and a body and are those expres-
   sions that can be applied to arguments and reduced, or
   evaluated, to a result.

   â€¢ Variables may be bound in the function declaration, and
   every time a bound variable shows up in a function, it has
   the same value.

   â€¢ All functions take one argument and return one result.

   â€¢ Functions are a mapping of a set of inputs to a set of
   outputs. Given the same input, they always return the
   same result.


** Look for Exercises in Pag. 28-31


** Definitions

   1. The lambda in lambda calculus is the greek letter Î» used
   to introduce, or abstract, arguments for binding in an expression.

   2. A lambda abstraction is an anonymous function or lambda term
   (Î»x.x + 1)

   The head of the expression, Î»x., abstracts out the term
   x + 1. We can apply it to any x and recompute different results
   for each x we applied the lambda to.

   3. Application is how one evaluates or reduces lambdas, this
   binds the argument to whatever the lambda was applied
   to. Computations are performed in lambda calculus by
   applying lambdas to arguments until you run out of ar-
   guments to apply lambdas to.

   (Î»x.x)1

   This example reduces to 1, the identity Î»x.x was applied
   to the value 1, x was bound to 1, and the lambdaâ€™s body is
   x, so it just kicks the 1 out. In a sense, applying the Î»x.x
   consumed it. We reduced the amount of structure we had.

   5. Normal order is a common evaluation strategy in lambda
   calculi. Normal order means evaluating (ie, applying or
   beta reducing) the leftmost outermost lambdas first, eval-
   uating terms nested within after youâ€™ve run out of argu-
   ments to apply. Normal order isnâ€™t how Haskell code is
   evaluated - itâ€™s call-by-need instead. Weâ€™ll explain this more
   
* Chapter 2
** Infix operators
*** Associativity and precedence
    #+BEGIN_SRC haskell
    :info (^)
    infixr  8   ^
    -- example of infixr
    2 ^ 3 ^ 4 == 2 ^ (3 ^ 4) -- True
    2 ^ 3 ^ 4 == (2 ^ 3) ^ 4 -- False
    -- example of infixl
    2 * 3 * 4 == (2 * 3) * 4 -- True
    #+END_SRC
** mod and rem
   One key difference here is that, in Haskell (not in all lan-
   guages), if one or both arguments are negative, the results of
   mod will have the same sign as the divisor, while the result of
   rem will have the same sign as the dividend:

   Prelude> (-5) `mod` 2
   1
   Prelude> 5 `mod` (-2)
   -1
   Prelude> (-5) `mod` (-2)
   -1
   But:
   Prelude> (-5) `rem` 2
   -1
   Prelude> 5 `rem` (-2)
   1
   prelude> (-5) `rem` (-2)
   -1

** Let and Where

   /let/ intruduces an expression, but /where/ is a declaration and is bound to
   a surrounding syntactic construct.

** Exercises Chap 2 pag 88-94

** Definitions

   1. The terms argument and parameter are often used inter-
   changeably. However, it is worthwhile to understand the
   distinction. A parameter, or formal parameter, represents a
   value that will be passed to the function when the func-
   tion is called. Thus, parameters are usually variables. An
   argument is an input value the function is applied to. A
   functionâ€™s parameter is bound to the value of an argument
   when the function is applied to that argument.

   2. An /expression/ is a combination of symbols that conforms
   to syntactic rules and can be evaluated to some result. In
   Haskell, an expression is a well-structured combination
   of constants, variables, and functions. While irreducible
   constants are technically expressions, we usually refer to
   those as â€œvaluesâ€, so we usually mean â€œreducible expres-
   sionâ€ when we use the term /expression/.

   3. A /value/ is an expression that cannot be reduced or evalu-
   ated any further. 2 * 2 is an expression, but not a value,
   whereas what it evaluates to, 4, is a value.

   4. A /function/ is a mathematical object whose capabilities are
   limited to being applied to an argument and returning a
   result. Functions can be described as a list of ordered pairs
   of their inputs and the resulting outputs, like a mapping.
   Given the function f x = x + 2 applied to the argument
   2, we would have the ordered pair (2, 4) of its input and
   output.

   5. /Infix/ notation is the style used in arithmetic and logic. Infix
   means that the operator is placed between the operands
   or /arguments/. An example would be the plus sign in an
   expression like 2 + 2.

   6. /Operators/ are functions that are infix by default. In Haskell,
   operators must use symbols and not alphanumeric characters.

   7. /Syntactic sugar/ is syntax within a programming language
      designed to make expressions easier to write or read.

* Chapter 3

** Concatenation
  #+BEGIN_SRC haskell
  concat [[1, 2], [2, 3]]
  [1, 2, 2, 3]

  (++) [1, 2, 3] [4, 5, 6]
  [1, 2, 3, 4, 5, 6]

  ["hello" ++ " world"]
  ["hello world"]

  concat ["hello", " world"]
  "hello world"
  #+END_SRC

** More list functions

   - The (:) operator, called /cons/, builds a list
     #+BEGIN_SRC haskell
     'c' : "hris"
     'P' : ""
     #+END_SRC

   - head returns the head or first element of a list:
     #+BEGIN_SRC haskell
     head "Papuchon"
     'P'
     #+END_SRC

   - tail returns the list with the head chopped off:
     #+BEGIN_SRC haskell
     tail "Papuchon"
     "apuchon"
     #+END_SRC

   - take returns the specified number of elements from the list, starting from the left:
     #+BEGIN_SRC haskell
     take 2 "Papuchon"
     "Pa"
     #+END_SRC

   - drop returns the remainder of the list after the specified number of elements has been droped:
     #+BEGIN_SRC haskell
     drop 4 "Papuchon"
     "chon"     drop 9001 "Papuchon"
     ""
     #+END_SRC

   - Infix operator (!!), returns the element that is in the specified position, start from 0:
     #+BEGIN_SRC haskell
     "Papuchon" !! 4
     'c'
     #+END_SRC

*** NOTE

   Note that while all these functions are standard Prelude functions,
   many of them are considered unsafe.
   They are unsafe because they do not cover the case where they are given an
   empty list as input. Instead they throw out an error message, or /exception/.

** EXERCISES Pag 122 -

** Definitions

   - A String is a sequence of characters. In Haskell, String is represented by a linked-list of Char values, aka [Char].

   - A type or datatype is a classification of values or data. Types in Haskell
   determine what values are members of the type or that inhabit the type.
   Unlike in other languages, datatypes in Haskell by default do not
   delimit theoperations that can be performed on that data.

   - Concatenation is the joining together of sequences of values.
   Often in Haskell this is meant with respect to the [], or list,
   datatype, which also applies to String which is[Char].
   The concatenation function in Haskell is (++) which has type [a] -> [a] -> [a].

   - Scope is where a variable referred to by name is valid.
   Another word used with the same meaning is visibility,
   because if a variable isnâ€™t visible itâ€™s not in scope.

   - Local bindings are bindings local to particular expressions.
   The primary delineation here from top level bindings is that local
   bindings cannot be imported by other programs or modules.

   - Top level bindings in Haskell are bindings that stand outside
   of any other declaration. The main feature of top-level bindings is that
   they can be mande availabe to other modules within your program or to other
   people's programs.

* Chapter 4

** Anatomy of a data declaration

   We will start with a basic datatype to see how datatypes are
   structured and get acquainted with the vocabulary. Bool isnâ€™t a
   datatype weâ€™ve seen yet in the book, but it provides for truth
   values. It is named after the great logician George Boole and
   the system of logic named for him. Because there are only two
   truth values, there are only two data constructors:

   #+BEGIN_SRC haskell
   data Bool = False | True
   --    [1]    [2] [3] [4]
   #+END_SRC

  1. Type constructor for datatype Bool. This is the name of the type and shows up
  in type signatures.

  2. Data constructor for the value False.

  3. Pipe | indicates a sum type or logical disjunction: or. So, a Bool value is
  True or False.

  4. Data constructor for the value True.

  The whole thing is called a data declaration. Data declarations
  do not always follow precisely the same pattern â€” there
  are datatypes that use logical conjunction (and) instead of disjunction,
  and some type constructors and data constructors may have arguments.

** Fractional Numbers

   Some computations involving numbers will be fractional
   rather than integral. A good example of this is the division
   function (/) which has type:

   (/) :: Fractional a => a -> a -> a

   The notation Fractional a => denotes a typeclass constraint.
   It tells us the type variable /a/ must implement the Fractional typeclass.
   Whatever type of number /a/ turns out to be, it must
   be a type that has an instance of the Fractional typeclass; that
   is, there must be a declaration of how the operations from
   that typeclass will work for the type.

** Comparing Values

   (==) :: Eq a => a -> a -> Bool

   (<) :: Ord a => a -> a -> Bool

   #+BEGIN_SRC haskell
   ['a', 'b'] > ['b', 'a']
   False

   'b' > 'a'
   True

   [1, 2] > [2, 1]
   False

   "Chris" > "Julie"
   False
   #+END_SRC

** Conditionals with if-then-else

   if CONDITION
   then EXPRESSION_A
   else EXPRESSION_B

   Hereâ€™s how it reduces:

   #+BEGIN_SRC haskell
   -- Given:
   x = 0

   if (x + 1 == 1) then "AWESOME" else "wut"
   -- x is zero

   if (0 + 1 == 1) then "AWESOME" else "wut"
   -- reduce 0 + 1 so we can see

   -- if it's equal to 1
   if (1 == 1) then "AWESOME" else "wut"

   -- Does 1 equal 1?
   if True then "AWESOME" else "wut"
   -- pick the branch based on the Bool value
   #+END_SRC
** Tuples
   - The number of values in a tuple is known as the tuple's /arity/.
   - The values within a tuple do not have to be of the same type.
   - The two-tuple is expressed at both the type level and term level with the
     constructor (,). It looks like this:

     #+BEGIN_SRC haskell
     data (,) a b = (,) a b

     (,) 8 10
     (8,10)

     (,) 8 "Julie"
     (8,"Julie")

     -- Two-tuple has some default convenience functions
     fst :: (a,b) -> a
     snd :: (a,b) -> b

     let myTup = (1 :: Integer, "blah")

     -- You can do
     import Data.Tuple
     swap myTup
     -- The result is:
     ("blah",1)

     -- We can also combine tuples with other expressions:
     2 + fst (1, 2)
     3

     2 + snd (1, 2)
     4

     -- patern matching on tuples:
     tupFunc :: (Int, [a]) -> (Int, [a]) -> (Int, [a])
     tupFunc (a, b) (c, d) = ((a + c), (b ++ d))

     #+END_SRC

** Lists

   - All elements of a list must be of the same type.
   - Lists have their own distinct [] syntax.
   - The number of values that will be in the list isn't specified in the type,
     unlike tuples where the arity is set in the type and immutable.

     #+BEGIN_SRC haskell
     p = "Papuchon"
     awesome = [p, "curry", ":)"]
     also = ["Quake", "The Simons"]

     -- (++) :: [a] -> [a] -> [a]
     awesome ++ also

     -- allAwesome :: [[[Char]]]
     allAwesome = [awesome, also]

     -- concat :: [[a]] -> [a]
     concat allAwesome
     #+END_SRC

** Exercises
   #+BEGIN_SRC haskell
   -- Exercise 10 pag 170
   f :: (a, b) -> (c, d) -> ((b, d), (a, c))
   f x y = ((snd x, snd y), (fst x, fst y))
   #+END_SRC

   - Correcting syntax
     #+BEGIN_SRC haskell
     -- Ex 1
     x = (+)
     adds xs = x w  1
     where w = length xs

     -- Ex 2
     id x = x

     -- Ex 3
     f (a, b) = fst (a, b)
     #+END_SRC
** Definitions

   - A /tuple/ is an ordered grouping of values. In Haskell, you
   cannot have a tuple with only one element, but there is a
   zero tuple also called unit or (). The types of the elements
   of tuples are allowed to vary, so you can have both (String,
   String) or (Integer, String). Tuples in Haskell are the usual
   means of briefly carrying around multiple values without
   giving that combination its own name.

   - A typeclass is a set of operations defined with respect to
   a polymorphic type. When a type has an instance of a
   typeclass, values of that type can be used in the standard
   operations defined for that typeclass. In Haskell, typeclasses
   are unique pairings of class and concrete instance.
   This means that if a given type /a/ has an instance of Eq, it
   has /only one instance of Eq.

   - Data constructors in Haskell provide a means of creating
   values that inhabit a given type. Data constructors in
   Haskell have a type and can either be constant values
   (nullary) or take one or more arguments, like functions.

   In the following example, Cat is a nullary data constructor
   for Pet and Dog is a data constructor that takes an argument:
   #+BEGIN_SRC haskell
   type Name = String

   data Pet = Cat | Dog Name
   #+END_SRC

   The data constructors have the following types:
   Prelude> :t Cat
   Cat :: Pet
   Prelude> :t Dog
   Dog :: Name -> Pet

   - Type constructors in Haskell are not values and can only be
   used in type signatures. Just as data declarations generate
   data constructors to create values that inhabit that type,
   data declarations generate type constructors which can be
   used to denote that type. In the above example, Pet is the
   type constructor. A guideline for differentiating the two
   kinds of constructors is that type constructors always go
   to the left of the = in a data declaration.

   - /Data declarations/ define new datatypes in Haskell. Data
   declarations /always/ create a new type constructor, but may
   or may not create new data constructors. Data declarations
   are how we refer to the entire definition that begins with
   the data keyword.

   - A type alias is a way to refer to a type constructor or type
   constant by an alternate name, usually to communicate something
   more specific or for brevity.
   #+BEGIN_SRC haskell
   type Name = String
   -- creates a new type alias Name of the
   -- type String *not* a data declaration,
   -- just a type alias declaration
   #+END_SRC

   - /Arity/ is the number of arguments a function accepts. This
   notion is a little slippery in Haskell as, due to currying, all
   functions are 1-arity and we handle accepting multiple
   arguments by nesting functions.

   - Polymorphism in Haskell means being able to write code
   in terms of values which may be one of several, or any,
   type. Polymorphism in Haskell is either parametric or
   constrained. The identity function, id, is an example of a
   parametrically polymorphic function:
   #+BEGIN_SRC haskell
   id :: a -> a
   id x = x
   #+END_SRC
   Here id works for a value of /any/ type because is doesn't use
   any information specific to a given type or set  of types.

   Another example:
   #+BEGIN_SRC haskell
   isEqual :: Eq a => a -> a -> Bool
   isEqual x y = x == y
   #+END_SRC
   isEqual is polymorphico, but /constrained/ or /bounded/ to the set of
   types which have an instance of the Eq typeclass.

** Names and variables
*** Names
    In Haskell there are seven categories of entities that have
    names: functions, term-level variables, data constructors, type
    variables, type constructors, typeclasses, and modules. Term-
    level variables and data constructors exist in your terms. Term
    level is where your values live and is the code that executes
    when your program is running. At the type level, which is used
    during the static analysis & verification of your program, we
    have type variables, type constructors, and typeclasses. Lastly,
    for the purpose of organizing our code into coherent groupings
    across different files, we have modules.

* Chapter 5

** The Function Type
   #+BEGIN_SRC haskell
   fst :: (a,b)  ->   a
   --      [1]  [2]  [3]
   #+END_SRC
   1. The first parameter of fst has the type (a, b). Note that
   the tuple type itself (,) takes two arguments /a/ and /b/.

   2. The function type, (->), has two parameters. One is (a,b)
   and one is result /a/.

   3. The result of the function, which has type /a/. Itâ€™s the same
   /a/ that was in the tuple (a, b).

** Currying
   Currying refers to the nesting of multiple functions, each accepting one
   argument and returning one result, to allow the illusion of multiple-parameter functions.
   #+BEGIN_SRC haskell
   data (->) a b
   #+END_SRC
   - If you are constructing a function that requires multiple parameters,
   then the /b/ can be another function (the /a/ can be another function as well).
   In that case, just like in lambda abstractions that have multiple heads, they are nested.

   - Let's check the type signature for addition:
     #+BEGIN_SRC haskell
     (+) :: Num a => a -> a -> a
     #+END_SRC
   - Functions in Haskell are nested like Matryoshka
   dolls in order to accept â€œmultipleâ€ arguments. The way
   the (->) type constructor for functions works means a -> a -> a
   represents successive function applications, each
   taking one argument and returning one result. The difference
   is that the function at the outermost layer is returning
   another function that accepts the next argument.
   This is called currying.

   - The (->) is an infix operator and right associative, so:
   #+BEGIN_SRC haskell
   map :: (a -> b) -> [a] -> [b]

   -- associates into
   map :: (a -> b) -> ([a] -> [b])
   #+END_SRC
   - This is to group the parameters into argument and result, since there can only
   be one argument and one result per arrow. Since all the arrows have the same precedence,
   the associativity does not change the precedence or order of evaluation.

   - Remember, when we have a lambda expression that appears to have two parameters,
   they are nested lambdas. Applying the expression to one argument returns a function that
   awaits application to a second argument.

   - The type constructor for functions and the types we sse above are the same thing,
   but written in Haskell. When there are â€œtwo argumentsâ€ in Haskell,
   we apply our function to an argument, just like when we apply a lambda expression to an
   argument, and then return a result that is a function and needs to be applied to a second argument.

** Partial application

   #+BEGIN_SRC haskell
   (+) :: Num a => a -> a -> a
   sumA = (+) 10
   sumB x = sumA x
   -- sumB is equal to 22

   addStuff :: Integer -> Integer -> Integer
   -- its the same as:
   addStuff :: Integer -> (Integer -> Integer)
   #+END_SRC
** Manual currtying and uncurrying
   - /Uncurrying/ means un-nesting the functions and replacing the two functions with a tuple
     of two values.

   - If you uncurry (+), the type changes from Num a => a -> a -> a to Num a => (a,a) -> a
     which better fits the description "takes two arguments, returns one result".

   - Uncurried functions: One function, many arguments.

   - Curried functions: Many functions, one argument apiece.

     #+BEGIN_SRC haskell
     nonsense :: Bool -> Integer
     nonsense True = 805
     nonsense False = 31337

     curriedFunction :: Integer -> Bool -> Integer
     curriedFunction i b = i + (nonsense b)

     uncurriedFunction :: (Integer, Bool) -> Integer
     uncurriedFunction (i,b) = i + (nonsense b)

     anonymous :: Integer -> Bool -> Integer
     anonymous = \i b -> i + (nonsense b)

     anonNested :: Integer -> Bool -> Integer
     anonNested = \i -> \b -> i + (nonsense b)
     #+END_SRC

     - Functions that /seem/ to accept multiple arguments such as with a -> a -> a -> a are
       /higher-order functions/: they yield more functions values as each argument is applied
       until there are no more (->) type constructors and it terminates in a non-function value.

** Currying and uncurrying existing functions

  - Consider the following example for currying:
    Prelude> let curry f a b = f (a, b)
    Prelude> :t curry
    curry :: ((t1, t2) -> t) -> t1 -> t2 -> t
    Prelude> :t fst
    fst :: (a, b) -> a
    Prelude> :t curry fst
    curry fst :: t -> b -> t
    Prelude> fst (1, 2)
    1
    Prelude> curry fst 1 2
    1

  - Then for uncurrying:
    Prelude> let uncurry f (a, b) = f a b
    Prelude> :t uncurry
    uncurry :: (t1 -> t2 -> t) -> (t1, t2) -> t
    Prelude> :t (+)
    (+) :: Num a => a -> a -> a
    Prelude> (+) 1 2
    3
    Prelude> uncurry (+) (1,2)
    3
** Sectioning

   - The term /sectioning/ specifically refers to partial application of infix operators,
     which has a special syntax and allows you to choose whether the argument you're partially
     applying the operator to is the first or second argument:

     Prelude> let x = 5
     Prelude> let y = (2^)
     Prelude> let z = (^2)
     Prelude> y x
     32
     Prelude> z x
     25

     This does not only work with arithmetic:

     Prelude> let celebrate = (++ " woot!")
     Prelude> celebrate "naptime"
     "naptime woot!"
     Prelude> celebrate "dogs"
     "dogs woot!"

** Exercises: pag 204
   #+BEGIN_SRC haskell
   -- Ex 7
   kessel :: (Ord a, Num b) => a -> b -> a; kessel = undefined
   kessel 1 2 :: (Num a, Ord a) => a
   #+END_SRC
** Polymorphism
** Exercises: Parametricity pag 213
** Polymorphic constants
   #+BEGIN_SRC haskell
   (-10) -- is a polymorphic constant. It will have to resolve into a concrete type at some point.

   -- We can force the compiler to be more specific about the types of numbers:
   x = 5 + 5 :: Int
   #+END_SRC

** Type inference
** Exercises pag 221
** Chapter Exercises
   #+BEGIN_SRC haskell
   c' :: a -> b -> b

   -- ex 6 pag 234
   co :: (b -> c) -> (a -> b) -> a -> c
   co f g = \a -> f (g a)
   co f g a = f (g a)
   #+END_SRC
** Definitions

   - /Polymorphism/:
     Refers to type variables which may refer to more than once concrete type.

   - /Type inference/:
     /Infer/ principal types from terms without needing explicit type annotations.
     With respect to Haskell, the principal type is the most generic type which still typechecks.
     More generally, Principal type is a property of the type system youâ€™re interacting with.
     Principal typing holds for that type system if a type can be found for a term in an environment
     for which all other types for that term are instances of the principal type.

     #+BEGIN_SRC haskell
     -- Given the inferred types
     a
     Num a => a
     Int

     -- The principal type here is the
     -- parametrically polymorphic 'a'.

     -- Given these types
     (Ord a, Num a) => a
     Integer

     -- The principal type is
     -- (Ord a, Num a) => a
     #+END_SRC

   - /Type variable/ is a way to refer to an unspecified type or set of types in Haskell type
     signatures. Type variables ordinarily will be equal to themselves throughout a type signature.
     Let us consider examples:
     #+BEGIN_SRC haskell
     id :: a -> a

     -- One type variable 'a' that occours twice,
     -- once as an argument, once as a result.
     -- Parametrically polymorphic, could be
     -- strictly anything.

     (+) :: Num a => a -> a -> a

     -- One type variable 'a', constrained
     -- to needing an instance of Num. Two
     -- arguments, one result.
     -- All the same type.
     #+END_SRC

   - /Typeclass/

   - /Parametricity/ states that the behavior of a function will be uniform across all concrete
     applications of the function. for example:
     #+BEGIN_SRC haskell
     id :: a -> a
     #+END_SRC
     - Can be understood to have the same exact behavior every type in Haskell without needing
       to see how it was writter. It is the same property that tell us:
       #+BEGIN_SRC haskell
       const :: a -> b -> a
       #+END_SRC
     - const /must/ return the first value - parametricity and the definition of the type requires it!

       #+BEGIN_SRC haskell
       f :: a -> a -> a
       #+END_SRC
     - Here, f can only return the first or second value, nothing
       else, and it will always return one or the other consistently without changing.
       If the function f made use of (+) or (*), its type would necessarily
       be constrained by the typeclass Num and thus be an example of ad-hoc, rather than
       parametric, polymorphism.

       #+BEGIN_SRC haskell
       blahFunc :: b -> String
       #+END_SRC

     - blahFunc totally ignores its argument and is effectively a constant value of type String
       which requires a throw-away argument for no reason.

       #+BEGIN_SRC haskell
       convList :: a -> [a]
       #+END_SRC

     - Unless the result is [], the resulting list has values that are all the same value.
       The list will always be the same length.

   - /Ad-hoc polymorphism/ (sometimes called "constrained polymorphism")
     #+BEGIN_SRC haskell
     (+) :: Num a => a -> a -> a

     -- the above functions is leveraging
     -- ad-hoc polymorphism via the
     -- Num typeclass

     c' :: a -> a -> a

     -- This functions is not,
     -- it's parametriclay polymorphic in 'a'.
     #+END_SRC

   - A module is the unit of organization that the Haskell programming language uses to collect
     together declarations of values, functions, data types, typeclasses, and typeclass
     instances. Any time you use â€œimportâ€ in Haskell, you are importing declarations from a module.
     Let us look at an example from the chapter exercises:

     #+BEGIN_SRC haskell
     {-# LANGUAGE NoMonomorphismRestriction #-}

     module DetermineTheType where
     --     ^ name of module
     #+END_SRC
     - Here we made our Haskell source file have a module and
       we named it DetermineTheType. We included a directive to
       the compiler to disable the monomorphism restriction before
       we declared the module. Also consider the following example
       using import:

       #+BEGIN_SRC haskell
       import Data.Aeson (encode)
       --     ^ the module Data.Aeson
       import Database.Persist
       --     ^ the module Database.Persist
       #+END_SRC
       - In the above example, we are importing the function encode declared in the module
         Data.Aeson along with any typeclass instances. With the module Database.Persist we
         are importing /everything/ it makes available.
* Chapter 6
** Eq typeclass
    #+BEGIN_SRC haskell
    (==) :: Eq a => a -> a -> Bool

    -- if we specialized (==)
    -- for [Char] aka String
    (==) :: [Char] -> [Char] -> Bool

    (==) "cat"
    :: [Char] -> Bool

    (==) "cat" "cat"
    :: Bool
    #+END_SRC

  - Trivial typeclass
    #+BEGIN_SRC haskell
    data Trivial = Trivial'

    instance Eq Trivial where
    Trivial' == Trivial' = True
    #+END_SRC
** Partial Function
   - A partial functions is one that doesn't handle all the possible cases, so there are possible
     scenarios in which we haven't defined any way for the code to evaluate.
     #+BEGIN_SRC haskell
     f :: Int -> Bool
     f 2 = True
     -- With this, if you pass f 3, you'll get a error because  you're not handling all inputs
     -- that aren't number 2

     f :: Int -> Bool
     f 1 = True
     f 2 = True
     -- Same thing, but now we handle the input 1

     f :: Int -> Bool
     f 1 = True
     f 2 = True
     f _ = False
     -- Now we have an uncondicional case that matches everything.
     #+END_SRC

     - Another solution is to use a datatype that isn't /huge/ lika Int if you only have a few
       cases you want to consider.

** Sometimes we need to ask for more
   #+BEGIN_SRC haskell
   -- datatype declaration
   data Identity a = Identity a

   -- instance definition
   instance Eq a => Eq (Identity a) where
   (==) (Identity v) (Identity v') = v == v'
   #+END_SRC

** Exercises: Eq Instances
** Num
*** Integral
    #+BEGIN_SRC haskell
    class (Real a, Enum a) => Integral a where
    quot :: a -> a -> a
    rem :: a -> a -> a
    div :: a -> a -> a
    mod :: a -> a -> a
    quotRem :: a -> a -> (a, a)
    divMod :: a -> a -> (a, a)
    toInteger :: a -> Integer
    #+END_SRC
*** Fractional
    - Num is a superclass of Fractional. The Fractional typeclass is defined as follows:
      #+BEGIN_SRC haskell
      class (Num a) => Fractional a where
      (/)          :: a -> a -> a
      recip        :: a -> a
      fromRational :: Rational -> a
      #+END_SRC
** Type-defaulting typeclasses
   - When you don't specify the concrete type..
     #+BEGIN_SRC haskell
     (/) :: Fractional a => a -> a -> a
     -- defaults to
     (/) :: Double -> Double -> Double

     -- and

     div :: Integral a => a -> a -> a
     -- defaults to
     div :: Integer -> Integer -> Integer
     #+END_SRC

   default Num Integer
   default Real Integer
   default Enum Integer
   default Integral Integer
   default Fractional Double
   default RealFrac Double
   default Floating Double
   default RealFloat Double

   #+BEGIN_SRC haskell
   -- you can go
   numId = id :: Num a => a -> a
   -- to
   intId = numId :: Integer -> Integer
   -- but you CAN'T
   altNumId = intId :: Num a => a -> a -- can't go from specialized type to a more generalized type
   #+END_SRC
** Ord
   - Typeclass Ord. Things that can be put in order.

   - Ord is constrained by Eq because if you're going to compare items in a list and put them ind order
     , you need a way to determine if they are equal.

   - You can nest functions to have more than two arguments, ex:
     #+BEGIN_SRC haskell
     m = max 7 (max 8 9)
     9
     #+END_SRC
*** Ord instances
    - When you derive Ord instances for a datatype, they rely on the way the datatype is defined,
      but if you write your own instance, you can define the behavior you want.
      #+BEGIN_SRC haskell
      data DayOfWeek =
      Mon | Tue | Wed | Thu | Fri | Sat | Sun deriving (Ord, Show, Eq)
      -- here tha values to the left are /less/ /than/ values to the right.
      -- Mon > Tue = False
      -- Sun > Mon = True

      -- If we wanted to express that Friday is aways the best day, we write our own Ord instance.
      data DayOfWeek =
      Mon | Tue | Wed | Thu | Fri | Sat | Sun derivinf (Eq, Show)
      instance Ord DayOfWeek where
      compare Fri Fri = EQ
      compare Fri _   = GT
      compare _ Fri   = LT
      compare _ _     = EQ

      -- compare Fri Sat
      -- GT

      -- compare Sat Mon
      -- EQ

      -- compare Sat Fri
      -- LT

      -- Mon > Fri
      -- False

      -- Fri > Sat
      -- True
      #+END_SRC

*** Ord implies Eq
    #+BEGIN_SRC haskell
    -- this will not typecheck
    check' :: a -> a -> Bool
    check' a a' = a == a'

    -- We need Eq, but we can add Ord to it ( in "real" code we use Eq because we want to be minimal)
    check' :: Ord a => a -> a -> Bool
    check' a a' = a == a'
    -- Ghc didn't ask for Ord, but anything that provides an instance of Ord /must/ by definition
    -- also already have an instance of Eq.

    -- How to know?
    -- Just do a :i Ord and it will return something like
    class Eq a => Ord a where
    -- The class definition for Ord says that any /a/ must provide an Eq instance.
    -- We can say that Eq is a /superclass/ of Ord.
    #+END_SRC

** Enum
   - This typeclass covers types that are enumerable, therefore have known predecessors and
     successors.

     #+BEGIN_SRC haskell
     class Enum a where
     succ :: a -> a
     pred :: a -> a
     toEnum :: Int -> a
     fromEnum :: a -> Int
     enumFrom :: a -> [a]
     enumFromThen :: a -> a -> [a]
     enumFromTo :: a -> a -> [a]
     enumFromThenTo :: a -> a -> a -> [a]

     instance Enum Ordering
     instance Enum Integer
     instance Enum Int
     instance Enum Char
     instance Enum Bool
     instance Enum ()
     instance Enum Float
     instance Enum Double
     #+END_SRC
** Show
   - Show is a typeclass that provides for the creating of human-readable string representations
     of structures data. GHCi uses Show to create String values it can print in the terminal.

   - Show is not a serialization format. Show is not suitable for saving data to a file, etc..

     #+BEGIN_SRC haskell
     class Show a where
     showsPrec :: Int -> a -> ShowS
     show :: a -> String
     showList :: [a] -> ShowS

     instance Show a => Show [a]
     instance Show Ordering
     instance Show a => Show (Maybe a)
     instance Show Integer
     instance Show Int
     instance Show Char
     instance Show Bool
     instance Show ()
     instance Show Float
     instance Show Double
     #+END_SRC

*** Printing and side effects
    #+BEGIN_SRC haskell
    -- This is a String value:
    myVal :: String

    -- This value is a /method/ or means of obtaining a value, by performing effects or I/O,
    -- of type String:
    ioString :: IO String
    #+END_SRC

    - () is BORING
    - An IO action is performed when we call main for our program.

*** Working with Show
    - Invoking the Show typeclass also invokes its methods, specifically a method of taking your
      values and turning them into values that can be printed to the screen.

      #+BEGIN_SRC haskell
      data Mood = Blah
      instance Show Mood where
      show _ = "Blah"
      #+END_SRC

    - We can derive the show instance
      #+BEGIN_SRC haskell
      data Mood = Blah deriving Show
      #+END_SRC
** Read
   - This typeclass is essentially the opposite of Show. Where Show takes things and turns them into
     human-readable strings, Read takes strings and turns them into things. Like Show, it's not a
     serialization format.

   - There's now way Read will aways work:

     Prelude> read "1234567" :: Integer
     1234567

     Prelude> read "BLAH" :: Integer
     ***Exception: Prelude.read: no parse

   - Read doesn't return a proper value as a result for /all possible/ inputs.

** Instances are dispatched by type
   - A typeclass defines a set of functions and/or values;

   - types have instances of that typeclass;

   - the instances specify the ways that type uses the functions of the typeclass.

     - Don't use typeclasses to define default values.
     - Please do not write typeclasses like this:
     #+BEGIN_SRC haskell
     class Numberish a where
     fromNumber :: Integer -> a
     toNumber :: a -> Integer
     defaultNumber :: a

     instance Numberish Age where
     fromNumber n = Age n
     toNumber (Age n) = n
     defaultNumber = Age 65

     instance Numberish Year where
     fromNumber n = Year n
     toNumber (Year n) = n
     defaultNumber = Year 1988
     #+END_SRC

     - This will not work:

       Prelude> defaultNumber

     - If you call the defaultNumber without the type, you get an error, because it has /no idea/
       what type defaultNumber is other than that it's provided by Numberish's instances.

     - You can use the Haskell type assertion to /dispatch/, or specify, what typeclass instance
       you want to get our defaultNumber from.

       Prelude> defaultNumber :: Age
       Age 65

       Prelude> defaultNumber :: Year
       Year 1988

** Gimme more operations
   #+BEGIN_SRC haskell
   add :: a -> a -> a
   add x y = x + y
   #+END_SRC

   - If you load it up, you'll get an error.

   - We need to add a Num constraint to the type a. Because our function can't accept a value of
     strictly /any/ type. We need something that has an instance of Num because we use the (+) function
     and (+) comes from Num.

     #+BEGIN_SRC haskell
     add :: Num a => a -> a -> a
     add x y = x + y
     #+END_SRC

     - Now it works fine!

   - Another:
     #+BEGIN_SRC haskell
     addWeird :: Num a => a -> a -> a
     addWeird x y =
       if x > 1
       then x + y
       else x
     #+END_SRC
     - We get another error, because we're using the (>) but we don't have the Ord constraint.
     - Num doesn't imply Ord.

       #+BEGIN_SRC haskell
       addWeird :: (Ord a, Num a) => a -> a -> a
       addWeird x y =
         if x > 1
         then x + y
         else x
       #+END_SRC
       - Now it should typecheck

*** Concrete types imply all the typeclasses they provid
** Chapter Definitions
   - 1. /Typeclass inheritance/ is when a typeclass has a superclass.
     #+BEGIN_SRC haskell
     class Num a => Fractional a where
     (/) :: a -> a -> a
     recip :: a -> a
     fromRational :: Rational -> a
     #+END_SRC
     - Here the typeclass Fractional /inherits/ from Num, Num is a /superclass/ of Fractional.
     - If you want to write an instance of Fractional for some /a/, that type /a/, must already
       have an instance of Num before you may do so.

     #+BEGIN_SRC haskell
     -- even though in principle
     -- this could work, it will fail because
     -- Nada doesn't have a Num instance

     newtype Nada = Nada Double deriving (Eq, Show)

     instance Fractional Nada where
       (Nada x) / (Nada y) = Nada (x / y)
       recip (Nada n) = Nada (recip n)
       fromRational r = Nada (fromRational r)
     #+END_SRC
     - If you try to load you will get an error for "No instance for (Num Nada)"

     - You need a Num instance first. Can't write one that makes sense? Then you're
       not allowed to have a Fractional instance either.

   - 2. /Effects/ are how we refer to /observable/ actions programs may take other than
     compute a value. If a function modifies some state or interacts with the outside world in a manner
     that can be observed, then we say it has an /effect/ on the world.

   - 3. IO is the type for values whose evaluation bears the possibility of causing side effects,
     such as printing text, reading text input from the user, reading or writing files,
     or connecting to remote computers. This will be explained in much more depth in the chapter on IO.

   - 4. An instance is the definition of how a typeclass should work for a given type.
     Instances are unique for a given combination of typeclass and type.

   - 5. In Haskell we have derived instances so that obvious or common typeclasses, such as Eq,
     Enum, Ord, and Show can have the instances generated based only on how the datatype
     is defined. This is so programmers can make use of these conveniences without writing
     the code themselves, over and over.

** Typeclass inheritance, partial
   - Pag 326

* Chapter 7
** Binding variables to values
   #+BEGIN_SRC haskell
   addOne 10 -- x is bound to 10
   addone 10 = 10 + 1 = 11

   -- We can use let expressions to declare and bind variables:
   bindExp :: Integer -> String
   bindExp x =
     let y = 5 in
     "the integer was: " ++ show x
     ++ " and y was: " ++ show y
     -- y is in scope because the let expression bind the variable y to 5. y is only in scope
     -- inside the let expression.
   #+END_SRC

   - Let's see something that won't work:
   #+BEGIN_SRC haskell
     bindExp :: Integer -> String
     bindExp x =
       let z = y + x in
         let y = 5 in
           "the integer was: "
           ++ show x ++ " and y was: "
           ++ show y ++ " and z was: "
           ++ show z
           -- This won't work. y is not in scope for the let z expression.
   #+END_SRC

   - In some cases, functions arguments are not visible in the function if they have benn shadowed.
     Let's see some /shadowing/
     #+BEGIN_SRC haskell
     binidExp :: Integer -> String
     bindExp x =
       let x = 10; y = 5 in
         "the integer was: " ++ show x
         ++ " and y was: " ++ show y
     #+END_SRC
   - Here the result never changes. x will always be 10.
     - Because Haskell is /lexical scoped/
** Anonymous functions
   - To construct functions and use them without giving them a name.
     #+BEGIN_SRC haskell
     -- Here's a function:
     triple :: Integer -> Integer
     triple x = x * 3

     -- Here's the same function but anonymous:
     (\x -> x * 3) :: Integer -> Integer

     -- You can give this function a name, making it not anonymous:
     trip :: Integer -> Integer
     trip = \x -> x * 3

     -- To apply an anonymous functions we'll often need to wrap in parentheses so that our intent is
     -- clear:
     (\x -> x * 3) 5

     --  If you do this you will get an error:
     \x -> x * 3 1
     -- The error is "Could not deduce (Num (a0 -> a)). To the computer, it looks like you're
     -- trying to use 3 as a functiona and apply 3 to 1.
     #+END_SRC
** Patern matching
   #+BEGIN_SRC haskell
   isItTwo :: Integer -> Bool
   isItTwo 2 = True
   isItTwo _ = False
   #+END_SRC

   - The order of pattern matches matters!!
     #+BEGIN_SRC haskell
     -- This will always return False, because it will match the "anything else" case first.
     isItTwo :: Integer -> Bool
     isItTwo _ = False
     isItTwo 2 = True
     #+END_SRC

*** Pattern matching tuples
    #+BEGIN_SRC haskell
    -- You can do like this:
    f :: (a, b) -> (c, d) -> ((b, d), (a, c))
    f x y = ((snd x, snd y), (fst x, fst y))

    -- Or using pattern matching to make it clear:
    f :: (a, b) -> (c, d) -> ((b, d), (a, c))
    f (a, b) (c, d) = ((b, d), (a, c))
    #+END_SRC
** Case expressions
   #+BEGIN_SRC haskell
   funcZ x =
     case x + 1 == 1 of
       True -> "AWESOME"
       False -> "wut"
   #+END_SRC

   - We could also write a case expression to tell if its argument is a palindrome:
   #+BEGIN_SRC haskell
   pal xs =
     case xs == reverse xs of
       True -> "yes"
       False -> "no"
   #+END_SRC

   - The above can also be written with a where clause:
     #+BEGIN_SRC haskell
     pal' xs =
       case y of
         True -> "yes"
         False -> "no"
       where y = xs == reverse xs
     #+END_SRC
*** High-order functions
    - /Higher-order functions/ (HOFs) are functions that accept functions as arguments.

    - Let's examine a standard higher-order function, flip:
      #+BEGIN_SRC haskell
      flip :: (a -> b -> c) -> b -> a -> c
      -- using (-) as our (a -> b -> c)
      t = flip (-) 10 1
      #+END_SRC

      #+BEGIN_SRC haskell
      flip :: (a -> b -> c) -> b -> a -> c
      flip f x y = f y x
      -- or
      flip f = \ x y -> f y x
      #+END_SRC
*** Guards
    - Between the | and the =, must evaluate to a Bool value.
    #+BEGIN_SRC haskell
    myAbs :: Integer -> Integer
    myAbs x
      | x < 0 = (-x)
      | otherwise = x
    #+END_SRC

    #+BEGIN_SRC haskell
    bloodNa :: Integer -> String
    bllodNa x
    | x < 135 = "too low"
    | x > 145 = "too high"
    | otherwise = "just right"
    #+END_SRC

    - Calculating if its a right triangle or not
      #+BEGIN_SRC haskell
      isRight :: (Num a, Eq a) => a -> a -> a -> String
      isRight a b c
      | a^2 + b^2 == c^2 = "RIGHT ON"
      | otherwise = "not right"
      #+END_SRC

    - Dog's age
      #+BEGIN_SRC haskell
      dogYrs :: Integer -> Integer
      dogYrs x
      | x <= 0 = 0
      | x <= 1 = x * 15
      | x <= 2 = x * 12
      | x <= 4 = x * 8
      | otherwise = x * 6
      #+END_SRC

    - Student grade
      #+BEGIN_SRC haskell
      avgGrade :: (Fractional a, Ord a) => a -> Char
      avgGrade x
      | y >= 0.9 = 'A'
      | y >= 0.8 = 'B'
      | y >= 0.7 = 'C'
      | y >= 0.59 = 'D'
      | y < 0.59 = 'F'
      where y = x / 100
      #+END_SRC
*** Function composition
    - Is a type of higher-order function that allows us to combine functions such that the result
      of applying one function gets passed to the next functions as an argument.

    - The basic syntaxt of function composition looks like this:
      #+BEGIN_SRC haskell
      (f . g) x = f (g x)

      negate . sum $ [1, 2, 3, 4]
      -- or
      (negate . sum) [1, 2, 3, 4]

      take 5 . reverse $ [1..10]
      -- first the list will be reversed and then first 5 elements of the new list will be returned

      f x = take 5 . enumFrom $ x
      g x = take 5 . filter odd . enumFrom $ x

      -- using the . operator for composing functions.
      (.) :: (b -> c) -> (a -> b) -> a -> c
      print :: Show a => a -> IO ()
      print a = (putStrLn . show) a

      -- point free version
      print :: Show a => a -> IO ()
      print = purStrLn . show
      #+END_SRC
*** Pointfree style
    - Composing functions without specifying their arguments.
      #+BEGIN_SRC haskell
      f . g = \x -> f (g x)
      f . g . h = \x -> f (g (h x))

      f = negate . sum

      f :: Int -> [Int] -> Int
      f z xs = foldr (+) z xs
      f = foldr (+)

      f = lenght . filter (== 'a') -- filter :: ( a -> Bool) -> [a] -> [a]
      -- (== 'a') :: Char -> Bool so it fits the (a -> Bool)
      #+END_SRC
*** Chapter Definitions
    - 1. /Binding/ or /bound/ ir a common word used to indicate connection, linkage, or association bettwen
      two objects. In Haskell we'll use it to talk about what value a variable has.
      #+BEGIN_SRC haskell
      blah :: Int
      blah = 10
      #+END_SRC
      - Here the variable blah is bound to the value 10.

    - 2. An anonymous function is a function which is not bound to an identifier and is instead 
      passed as an argument to another function and/or used to construct another function.
      #+BEGIN_SRC haskell
      \x -> x
      -- anonymous version of id

      id x = x
      -- not anonymous, its bound to 'id'
      #+END_SRC

    - 3. Currying is the process of transforming a function that takes multiple arguments into a
      series of functions which each take one argument and return one result. This is accomplished
      through the nesting. In Haskell, all functions are curried by default.
      You donâ€™t need to do anything special yourself.
      #+BEGIN_SRC haskell
      -- curry and uncurry already exist in Prelude
      curry' :: ((a, b) -> c) -> a -> b -> c
      curry' f a b = f (a, b)

      uncurry' :: (a -> b -> c) -> ((a, b) -> c)
      uncurry' f (a, b) = f a b

      -- uncurried function,
      -- takes a tuple of its arguments
      add :: (Int, Int) -> Int
      add (x, y) = x + y

      add' :: Int -> Int -> Int
      add' = curry' add

      f a b = a + b
      -- is equivalent to
      f = \a -> (\b -> a + b)
     #+END_SRC

    - 4. /Pattern matching/ is a syntactic way of deconstructing product and sum types to get at their
      inhabitants.
      #+BEGIN_SRC haskell
      -- nullary data constructor, not a sum or product.
      -- Just a single value.
      data Blah = Blah
      -- Pattern matching on Blah can only do one thing.
      blahFunc :: Blah -> Bool
      blahFunc Blah = True

      data Identity a = Identity a deriving (Eq, Show)
      -- when you pattern match on identity you can unpack and expose the 'a'

      unpackIdentity :: Identity a -> a
      unpackIdentity (Indetity x) = x

      -- choose to ignore the contents of Identity
      ignoreIdentity :: Identity a -> Bool
      ignoreIdentity (Identity _) = True

      -- or ignore it completely since matching on a non-sum data constructor
      -- changes nothing.
      ignoreIdentity' :: Identity a -> Bool
      ignoreIdentity' _ = True

      data Product a b = Product a b deriving (Eq, Show)
      -- Now we can choose to use none, one, or both of the values in the product of a and b:
      productUnpackOnlyA :: Product a b -> a
      productUnpackOnlyA (Product x _ ) = x

      productUnpackOnlyB :: Product a b -> b
      productUnpackOnlyB (Product _ y) = y

      -- Or we can bind them both to a different name:
      productUnpack :: Product a b -> (a, b)
      productUnpack (Product x y) = (x, y)

      -- =============================================

      data SumOfThree a b c =
        FirstPossible a
        | SecondPossible b
        | ThirdPossible c
        deriving (Eq, Show)

        -- Now we can discriminate by the inhabitants of the sum and choose to do different things based
        -- on which constructor in the sum they were.
        sumToInt :: SumOfThree a b c -> Integer
        sumToInt (FirstPossible _) = 0
        sumToInt (SecondPossible _) = 1
        sumToInt (ThirdPossible _) = 2

        -- We can selectively ignore inhabitants of the sum
        sumToInt :: SumOfThree a b c -> Integer
        sumToInt (FirstPossible _) = 0
        sumToInt _ = 1
      #+END_SRC

    - /Bottom/ is a non-value used to denote that the program cannot return a value or result.
      The most elemental manifestation of this is a program that loops infinitely.

      #+BEGIN_SRC haskell
      -- If you apply this to any values, it'll recurse indefinitely.
      f x = f x

      -- It'll a'splode if you pass False
      dontDoThis :: Bool -> Int
      dontDoThis True = 1

      -- morally equivalent to
      definetelyDontDoThis :: Bool -> Int
      definetelyDontDoThis True = 1
      definetelyDontDoThis False = error "oops"
      -- don't use error
      -- there's a better way.
      #+END_SRC

    - 6. High-order functions
      #+BEGIN_SRC haskell
      -- Technically higher order because of currying
      Int -> Int -> Int

      -- see? Returns another functions after applying the first arg
      -- -> is right associative
      Int -> (Int -> Int)

      -- The rest of the following examples are types of higher order functions

      (a -> b) -> a -> b

      (a -> b) -> [a] -> [b]

      (Int -> Bool) -> [Int] -> [Bool]

      -- also higher order, this one takes a function argument which itself is higher order as well.
      ((a -> b) -> c) -> [a] -> [c]
      #+END_SRC

    - 7. /Composition/ is the application of a function to the result of having applied another function.
      The composition operator is a higher-order function as it takes the functions it composes as
      arguments and then returns a function of the composition:
      #+BEGIN_SRC haskell
      (.) :: (b -> c) -> (a -> b) -> a -> c

      -- is
      (.) :: (b -> c) -> (a -> b) -> (a -> c)

      -- or
      (.) :: (b -> c) -> ((a -> b) -> (a -> c))

      -- can be implemented as
      comp :: (b -> c) -> ((a -> b) -> (a -> c))
      comp f g x = f (g x)
      -- The function g is applied to x, f is applied to the result of g x.
      #+END_SRC

    - 8. /Pointfree/ is programming tacitly, or without mentioning arguments by name. This tends to
      look "plumby" code where you're routing data around implicitly or leabing off unnecessary
      arguments thanks to currying. The "point" referred to in the term pointfree is an argument.

      #+BEGIN_SRC haskell
      -- not pointfree
      blah x = x
      addAndDrop x y = x + 1
      reverseMkTuple a b = (b, a)
      reverseTuple (a, b) = (b, a)

      -- pointfree versions
      blah = id
      addAndDrop = const . (1 +) -- don't understand
      reverseMkTuple = flip (,)
      reversetuple = uncurry (flip (,))
      -- another example: curry (\(a, b) -> a + b) 10 20

      -- f = \x -> (\y -> x + y) 10 20
      -- f = (\y -> 10 + y) 20
      -- f = 10 + 20
      #+END_SRC
* Chapter 8
  - Recursion is a means of expressing code that mnust take an /indefinite/ number of steps to
    return a result.
    - We use a combinator - known as the Y combinator or fixed-point combinator - to write recursive
      functions in the lambda calculus.
      #+BEGIN_SRC haskell
      -- no base case
      brokenFact1 :: Integer -> Integer
      brokenFact1 n = n * brokenFact1 (n - 1)

      -- let's apply
      brokenFact1 4 =
        4 * (4 -1)
        * ((4 - 1) - 1)
        * (((4 - 1) - 1) - 1) -- this won't stop
      #+END_SRC

    - Intermission: Exercise
      #+BEGIN_SRC haskell
      applyTimes :: (Eq a, Num a) => a -> (b -> b) -> b -> b
      applyTimes 0 f b = b
      applyTimes n f b = f (applyTimes (n - 1) f b)
      -- or
      applyTimes n f b = f . applyTimes (n - 1) f $ b

      -- evaluation
      applyTimes 5 (+1) 5
      = applyTimes (+1) $ applyTimes 4 (+1) 5 -- keep going
      = applyTimes (+1) $ (+1) $ applyTimes 3 (+1) 5
      = applyTimes (+1) $ (+1) $ (+1) $ applyTimes 2 (+1) 5
      = applyTimes (+1) $ (+1) $ (+1) $ (+1) $ applyTimes 1 (+1) 5
      = applyTimes (+1) $ (+1) $ (+1) $ (+1) $ (+1) $ applyTimes 0 (+1) 5 -- now it returns 5
      = (+1) $ (+1) $ (+1) $ (+1) $ (+1) $ 5
      = 10

      -- another example
      incTimes 3 5 = 1 + (incTimes (3 - 1) 5)
      = 1 + (incTimes (2 - 1) 5)
      = 1 + 1 + (incTimes (1 - 1) 5) -- times == 0 so it returns n
      = 1 + 1 + 1 + 5
      = 8
      #+END_SRC

  - /Bottom/ is a term used in Haskell to refer to computations that do not successfully result in
    a value.
    Let's examine a few ways by which we can have bottom in our programs:
    #+BEGIN_SRC haskell
    x = x in x
    #+END_SRC
    Next let's define a function that will return an exception:
    #+BEGIN_SRC haskell
    f :: Bool -> Int
    f True = error "blah"
    f False = 0
    #+END_SRC
    - When we evaluate f True, we get an exception, which is a bottom too.

  - Fibonacci
    #+BEGIN_SRC haskell
    fibonacci :: Integral a => a -> a
    fibonacci 0 = 0
    fibonacci 1 = 1
    fibonacci n = fibonacci (n - 1) + fibonacci (n - 2)

    -- evaluation
    fibonacci 3 = fibonacci (3 - 1) + fibonacci (3 - 2)
    fibonacci (2 - 1) + fibonacci (2 - 2)
    #+END_SRC

  - Integral division from sratch
    #+BEGIN_SRC haskell
    -- we can do
    dividedBy :: Integer -> Integer -> Integer
    dividedBy = div

    -- or to make more obvious
    type Numerator = Integer
    type Denominator = Integer
    type Quotient = Integer
    dividedBy :: Numerator -> Denominator -> Quotient
    dividedBy = div
    #+END_SRC
    - The type keyword declares a type synonym, or type alias.

** Definitions
   - /Recursion/ is a means of computing results that may require an indefinite amount of work to
     obtain through the use of repeated function application. Most recursive functions that terminate
     or otherwise do useful work will often have a case that calls itselff and a base case that acts
     as a backstop of sorts for the recursion.
     #+BEGIN_SRC haskell
     -- not recursive
     lessOne :: Int -> Int
     lessOne n = n - 1

     -- recursive
     zero :: Int -> Int
     zero 0 = 0
     zero n = zero (n - 1)
     #+END_SRC

* Chapter 9
** Lists
** The list datatype
   #+BEGIN_SRC haskell
   data []  a   =   []  |   a : [a]
   --  [1] [2] [3] [4] [5]    [6]

   -- 1. The datatype with the type constructor []
   -- 2. takes a single type constructor argument 'a';
   -- 3. at the term level can be constructed via
   -- 4. nullary constructor []
   -- 5. /or/ can be constructed by
   -- 6. data constructor (:) which is a product of a value of the type 'a' we mentioned in the type
   --    constructor /and/ a value of type [a], that is "more list".
   #+END_SRC
** Pattern matching on lists
   #+BEGIN_SRC haskell
   -- Match on the first argument to the infix (:) constructor, ignoring the rest of the list.
   myHead :: [t] -> t
   myHead (x : _) = x

   -- we can do the opposite as well:
   myTail :: [t] -> [t]
   myTail (_ : xs) = xs

   -- better way:
   safeTail :: [a] -> Maybe [a]
   safeTail [] = Nothing
   safeTail (x:[]) = Nothing
   safeTail (_:xs) = Just xs
   #+END_SRC
** List's syntactic sugar
   - Haskell has some syntactic sugar on lists:
     #+BEGIN_SRC haskell
     [1, 2, 3] ++ [4] = [1, 2, 3, 4]
     -- rather than:
     (1 : 2 : 3 : []) ++ 4 : [] = [1, 2, 3, 4]

     -- : is infixr so:
     (1 : (2 : (3 : [])))
     #+END_SRC
   - When we talk about lists, we often talk about them in terms of â€œcons cellsâ€ and spines.
     The syntactic sugar obscures this underlying construction, but looking at the desugared version
     above may make it more clear. The cons cells are the list datatypeâ€™s second data constructor,
     a : [a], the result of recursively prepending a value to â€œmore list.â€ The cons cell is
     a conceptual space that values may inhabit. The spine is the connective structure that holds
     the cons cells together and in place. As we will soon see, this structure
     nests the cons cells rather than ordering them in a right-toleft row. Because different
     functions may treat the spine and the cons cell differently, it its important to understand
     this underlying structure.

** Using ranges to construct lists
   #+BEGIN_SRC haskell
   [1..10]
   enumFromTo 1 10
   [1,2..10]
   enumFromThenTo 1 2 10
   #+END_SRC

** Extracting portions of lists
   #+BEGIN_SRC haskell
   take 7 ['a'..'z']
   take 3 [1..10]
   take 10 (enumFrom 10)

   -- drop specified number of elements off the beginning of the list:
   drop 4 [1..10]
   drop 8 ['a'..'z']
   drop 4 []
   drop 2 (enumFromTo 10 20)

   -- The splitAt function cuts a list into two parts at the element specified and return a tuple
   -- of the two lists
   splitAt 5 [1..10]
   splitAt 10 ['a'..'z']
   splitAt 3 (enumFromTo 5 15) -- remember that the 3 is the position and not the element value.

   takeWhile (<3) [1..10]
   takeWhile (<8) (enumFromTo 5 15)
   takeWhile (<8) (enumFrom 3)

   dropWhile (<8) [1..10]
   dropWhile (>6) [1..10] -- [1,2,3,4,5,6,7,8,9,10]
   #+END_SRC
** List comprehensions
   - Means of generating a new list from a list or lists. They come from the concept of
     set comprehensions in mathematics.
     #+BEGIN_SRC haskell
     -- simple example
     [ x^2   |   x <- [1..10]]
     --[1]  [2]    [   3   ]
     -- 1. This is the output function that will apply to the members of the list we indicate.
     -- 2. The pipe here designates the separation between the output function and the input.
     -- 3. This is the input set: a generator list and a variable that represents the elements
     --    that will be drawn from that list. This says, "from a list of number from 1-10, take(<-)
     --    each element as an input to the output function".
     #+END_SRC
   - Adding predicates
     - List comprehensions can optionally take predicates that limit the elements drawn from
       the generator list. The predicates must evaluate to Bool values, as in other
       condition-placing function types weâ€™ve looked at (for example, guards). Then the
       items drawn from the list and passed to the output function will only be those that met
       the True case in the predicate.
       #+BEGIN_SRC haskell
       [x^2 | x <- [1..10], rem x 2 == 0]

       -- multiple generators
       [x^y | x <- [1..10], y <- [2, 3]] = [1,1,4,8,9,27,16,64,25,125]
       -- 1^2, 1^3, 2^2, 2^3, 3^2, 3^3, 4^2, 4^3...

       -- we can place a condition
       [x^y | x <- [1..10], y <- [2, 3], x^y < 50]

       -- We can use multiple generators to turn two lists into a list of tuples:
       [(x,y) | x <- [1,2,3], y <- [6,7]]

       -- another examples
       [(x,y) | x <- [1, 2, 3], y <- ['a', 'b']]

       [[x,y,z] | x <- ['a','b','c'], y <- ['a','b','c'], z <- ['a','b','c']]
       #+END_SRC

     - List comprehensions with Strings
       #+BEGIN_SRC haskell
       -- Remove all lowercase letters
       [x | x <- "Three Letter Acronym", elem x ['A'..'Z']]

       -- better
       myAcronym xs = [x | x <- xs, elem x ['A'..'Z']]
       #+END_SRC
** Spines and nonstrict evaluation
   - /Spine/ is the connective structure that ties the collection of values together. In the case
     of a list, the spine is usually textually represented by the recursive cons (:) operators.
     1 : 2 : 3 : []
     or
     1 : (2 : (3 : []))
     - The problem with the 1 : (2 : (3 : [])) representation we used is that it make it seem like
       the value 1 exists "before" the cons (:) cell that contains it, but actually, the cons
       cells contain the values.
       #+CAPTION: Representation of the list spine
       #+NAME:   fig:list-spine
       [[list-spine.png]]

*** Using GHCi's :sprint command
    Prelude> blah = enumFromTo 'a' 'z'
    Prelude> :sprint blah
    Prelude> blah = _
    - The blah = _ indicates that blah is totally unevaluated.

    Prelude> take 1 blah
    Prelude> "a"
    Prelude> :sprint blah
    Prelude> blah 'a' : _
    - So we've evaluated a cons cell : and the first value 'a'.

   Prelude> take 2 blah
   Prelude> "ab"
   Prelude> :sprint blah
   Prelude> blah = 'a' : 'b' : _
   - 'take 2 blah' forces evaluation of the second cons cell and the second value.

   - The length function is only strict in the spine, meaning it only forces evaluation of the spine
     of a list, not the values, something we can see if we try to find the length of a list of
     undefined values. BUT we can't see with the :sprint command...

*** Spines are evaluated independently of values
    - Values in Haskell get reduced to weak head normal form. 'Normal form' means that the expression
      is fully evaluated. 'Weak head normal form' means that the expression is only evaluated as
      far as is necessary to reach a data constructor. (WHNF) (NF)
      #+BEGIN_SRC haskell
      (1, 2) -- WHNF & NF.. its fully evaluated

      (1, 1 + 1) -- WHNF.. The (+) could be evaluated be hasn't been yet.

      \x -> x * 10 -- WHNF & NF... This is in NF because it cannot be reduced further until the outer
      --                          x -> ... has been applied. With nothing further to reduce, it is
      --                          in normal form.

      "Papu" ++ "chon" -- This string concatenation is in neither WHNF nor NF, this is because
      --                  the outermost component of the expression is a function, (++), whose
      --                  arguments are fully applied but it hasn't been evaluated.
      -- Whereas, the following would be in WHNF but not NF:
      (1, "Papu" ++ "chon")
      #+END_SRC

    - When we define a list and define all its values, it is in NF and all its values are known.
      There's nothing left to evaluate at that point, example:

      Prelude> let num :: [Int]; num = [1, 2, 3]
      Prelude> :sprint num
      num = [1,2,3]

      - https://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form

** Transforming list of values
   - map: apply a function to each member of a list.
   - fmap: can be applied to data other than lists.
     #+BEGIN_SRC haskell
     map :: (a -> b) -> [a] -> [b]
     fmap :: Functor f => (a -> b) -> f a -> f b
     #+END_SRC
   - Here's how map is defined in base:
     #+BEGIN_SRC haskell
     map :: (a -> b) -> [a] -> [b]
     map _  []  =   []
     -- [1] [2]     [3]
     map f (x:xs)   = f x  :  map f xs
     -- [4] [5]       [6] [7]  [8]
     -- pag 503, 504
     #+END_SRC

     - How do we write out what map f does? Note, this order of evaluation doesn't represent the proper
       nonstrict evaluation order, but does give an idea of what's going on:
       #+BEGIN_SRC haskell
       map (+1) [1,2,3]
       -- desugared, (:) is infixr 5,
       -- so it's right-associative
       map (+1) (1 : (2 : (3 : [])))

       -- Not an empty list, so second
       -- pattern-match in map fires.
       -- Apply (+1) to value, then map
       (+1) 1 :
         map (+1)
           (2 : (3 : []))

      -- Apply (+1) to the next value, cons onto
      -- the result of mapping over the rest
      (+1) 1 :
        ((+1) 2 :
          (map (+1)
            (3 :[])))

        -- Last time we'll trigger the
        -- second-case of map
        (+1) 1 :
          ((+1) 2 :
            ((+1) 3 :
              (map (+1) [])))

         -- Now we trigger the base-case that
         -- handles empty lists and returns the
         -- empty list.
         (+1) 1 :
           ((+1) 2 :
             ((+1) 3 : []))

       -- Now we reduce
       2 : ((+1) 2 : ((+1) 3 : []))
       2 : 3 : (+1) 3 : []
       2 : 3 : 4 : [] == [2, 3, 4]


       -- Using the syntactic sugar of lists, here's an approximation of what map is doing for us:
       map f [1, 2, 3] == [f 1, f 2, f 3]

       map (+1) [1, 2, 3]
                [(+1) 1, (+1) 2, (+1) 3]
                [2, 3, 4]

      -- Or using spine syntax:
      -- PAG 506, 507
       #+END_SRC

     - These representations do not account for nonstrict evaluation. Crucially, map doesn't traverse
       the whole list and apply the function immediately. The functions is applied to the values you
       force out of the list one by one.

       Prelude> map (+1) [1, 2, 3]
       [2, 3, 4]
       -- The whole list was forced

       Prelude> take 2 $ map (+1) [1, 3, undefined]
       [2, 3]
       -- The undefined value was never forced

       #+BEGIN_SRC haskell
       map fst [(2, 3), (4, 5), (6, 7)]
       [2, 4, 6]

       -- map a partially applied take function:
       map (take 3) [[1..5], [1..5], [1..5]]
       [[1,2,3],[1,2,3],[1,2,3]]

       -- map if-then-else using anonymous function.
       map (\x -> if x == 3 then (-x) else (x)) [1..10]
       #+END_SRC
** Filtering lists of values
   - filter has the following definition:
     #+BEGIN_SRC haskell
     filter :: (a -> Bool) -> [a] -> [a]
     filter _ [] = []
     filter p (x:xs)
       | p x = x : filter p xs
       | otherwise = filter p xs
     #+END_SRC
     - Ex4.hs

** Zipping lists
   - Zipping lists is combining values from multiple lists into a single list.
   - zipWith function allow you to use a combining function to produce a list of results from two
     lists.

   - Let's look at zip:
     Prelude> :t zip
     zip :: [a] -> [b] -> [(a,b)]

     Prelude> zip [1,2,3] [4,5,6]
     [(1,4), (2,5), (3,6)]

     - zip stops as soon as one of the lists runs out of values:
       Prelude> zip [1, 2] [4, 5, 6]
       [(1,4), (2,5)]

     - Will return an empty list if either of the lists is empty:
       Predule> zip [] [1..1000]
       []

     - zip proceeds until the shortes list ends.
       Prelude> zip ['a'] [1..10000000000]
       [('a', 1)]

       Prelude> zip [1..100] ['a'..'c']
       [(1, 'a'), (2, 'b'), (3, 'c')]

   - We can use unzip to recover the lists as they were before they were zipped:

     Prelude> zip [1, 2, 3] [4, 5, 6]
     [(1,4),(2,5),(3,6)]
     Prelude> unzip $ zip [1,2,3] [4,5,6]
     ([1,2,3], [4,5,6])
     Prelude> fst $ unzip $ zip [1,2,3] [4,5,6]
     [1,2,3]
     Prelude> snd $ unzip $ zip [1,2,3] [4,5,6]
     [4,5,6]

     - information can be LOST in this process because zip must stop on the shortes list:
       Prelude> snd $ unzip $ zip [1,2] [3,4,5]
       [3,4]
* Chapter 10
  - Folds
    #+BEGIN_SRC haskell
        -- Remember how map worked?
    map :: (a -> b) -> [a] -> [b]
    map (+1) 1 : 2 : 3 : []
    = (+1) 1 : (+1) 2 : (+1) 3 : []

    -- Given the list
    foldr (+) 0 (1 : 2 : 3 : [])
    1 + (2 + (3 + 0))
    #+END_SRC
    - Where map applies a function to each member of a list and returns a list, a fold replace the
      cons constructors with the function and reduces the list.
** Fold right
   - We call foldr the "right fold" because the fold is right associative;
     #+BEGIN_SRC haskell
     foldr :: (a -> b -> b) -> b -> [a] -> b
     foldr f z [] = z
     foldr f z (x:xs) = f x (foldr f z xs)
     #+END_SRC

   - How foldr evaluates
     #+BEGIN_SRC haskell
     foldr :: (a -> b -> b) -> b -> [a] -> b
     foldr f z xs =
       case xs of
         [] -> z
         (x:xs) -> f x (foldr f z xs)

      foldr (+) 0 [1,2,3] =
        case [1,2,3] of
          [] -> 0
          (1:[2,3]) -> (+) 1 (foldr (+) 0 [2,3])

      foldr (+) 0 [2,3] =
        case [2,3] of
          [] -> 0
          (2: [3]) -> (+) 2 (foldr (+) 0 [3])

      foldr (+) 0 [3] =
        case [3] of
          [] -> 0
          (3 :[]) -> (+) 3 (foldr (+) 0 []) -- now it triggers the base case

      foldr (+) 0 [] =
        case [] of
        [] -> 0 -- dim dim
     #+END_SRC

     #+BEGIN_SRC haskell
     foldr (+) 0 [1,2,3]
     -- Into:
     (+) 1 ((+) 2 ((+) 3 0))
     #+END_SRC

** See how the fold associates.
   #+BEGIN_SRC haskell
   xs = map show [1..5]
   y = foldr (\x y -> concat ["(",x,"+",y,")"]) "0" xs
   #+END_SRC

   - You can use functions that are not strict in both arguments and therefore do not require
     evaluation of every value in order to return a result. The function myAny, can return a
     True result as sson as it finds one True:
     #+BEGIN_SRC haskell
     myAny :: (a -> Bool) -> [a] -> Bool
     myAny f xs =
       foldr (\x b -> f x || b) False xs

       -- using scanr with this func
       scanr (\x b -> (x > 10) || b ) False [1,11,8,10]
       = [True,True,False,False,False]
       --       [3]        [2]   [1]
       -- [1] when the recursion hit the empty list returns False
       -- [2] 10 > 10 is false
       -- [3]
     foldr const [1..5]
     foldr const 0 [1,undefined] -- = (1 `const` (undefined `const` 0)) == 1, never evaluates the undefined
     foldr const 0 ([1,2] ++ undefined)
     foldr const 0 [undefined, 2] -- error undefined
     #+END_SRC

   - Take is nonstrict
     #+BEGIN_SRC haskell
     xs = [1,2] ++ undefined
     length $ take 2 $ take 4 xs
     -- It doesn't matter that take 4 could've hit the bottom! Nothing forced it to because of the
     -- take 2 between it and length.
     #+END_SRC

** Fold left
   #+BEGIN_SRC haskell
   foldl :: (b -> a -> b) b -> [a] -> b
   foldl f acc [] = acc
   foldl f acc (x:xs) = foldl f (f x acc) xs

   -- given the list
   foldl (+) 0 (1 : 2 : 3 : [])

   -- foldl associates like this
   ((0 + 1) + 2) + 3
   #+END_SRC

** Associativity and folding
   #+BEGIN_SRC haskell
   [1..3] == 1 : 2 : 3 : []

   foldr f z [1, 2, 3]
   1 `f` (foldr f z [2,3])
   1 `f` (2 `f` (foldr f z [3]))
   1 `f` (2 `f` (3 `f` (foldr f z [])))
   1 `f` (2 `f` (3 `f` z))


   foldr (^) 2 [1..3]
   (^) 1 ((^) 2 ((^) 3 2)) == 1

   foldl (^) 2 [1..3]
   ((2 ^ 1) ^ 2) ^ 3 == 64

   foldr (:) [] [1..3]
   1 : (2 : (3 : []))

   foldl (flip (:)) [] [1..3]
   ((([] `f` 1) `f` 2) `f` 3)
   (([1] `f` 2) `f` 3)
   ([2,1] `f` 3)
   [3,2,1]

   foldr const 0 [1..5]
   (const 1 _)
   const 1 (const 2 (const 3 (const 4 (const 5 0))))
   --    1      2         3         4          5 <-
   1

   foldr (flip const) 0 [1..5]
   (flip const) 1 (flip const 2 (flip const 3 (flip const 4 (flip const 5 0))))
   --           0        0               0              0            0 <-
   0
   #+END_SRC
** Unconditional spine recursion
   - while foldl unconditionally evaluates the spine you can still selectively evaluates the values
     in the list.
     #+BEGIN_SRC haskell
     -- this will throw an error because the bottom is part of the spine and foldl must evaluate
     -- the spine
     xs = [1..5] ++ undefined
     foldl (\_ _ -> 5) 0 xs

     -- This is ok because bottom is a value here:
     xs = [1..5] ++ [undefined ]
     foldl (\_ _ -> 5) 0 xs
     #+END_SRC
** How to write fold function
   #+BEGIN_SRC haskell
   -- setup beginning of the expression
   foldr (\a b -> take 3 a ++ b) "" ["Pizza", "Apple", "Banana"]
   -- or
   foldr ((++) . (\a -> take 3 a)) "" ["Pizza", "Apple", "Banana"]
   #+END_SRC

** Summary
   - Scans
     #+BEGIN_SRC haskell
     scanr (+) 0 [1..3]
     [1 + (2 + (3 + 0)), 2 + (3 + 0), 0]
     [6, 5, 3, 0]

     scanl (+) 0 [1..3]
     [0, 0 + 1, 0 + 1 + 2, 0 + 1 + 2 + 3]
     [0, 1, 3, 6]

     scanl (+) 1 [1..3]
     -- unfolding the definition of scanl
     = [1, 1 + 1, (1 + 1) + 2, ((1 + 1) + 2) + 3]
     -- evaluating addition
     = [1,2,4,7]

     -- definition
     scanl :: (a -> b -> a) -> a -> [b] -> [a]
     scanl f q ls =
       q : (case ls of
             [] -> []
             x:xs -> scanl f (f q x) xs)
     #+END_SRC
** Definitions
   - A /fold/ is a higher-order function which, given a function to accumulate the results and
     a recursive data structure, return the built up value. The term fold is typically used
     with reference to collections of values referenced by a recursive datatype.

   - A /catamorphism/ is a generalization of folds to arbitrary datatypes.
     - notice a pattern:
   #+BEGIN_SRC haskell
   data Bool = False | True
   bool :: a -> a -> Bool -> a

   data Maybe a = Nothing | Just a
   maybe :: b -> (a -> b) -> Maybe a -> b
   #+END_SRC

   - A /tail call/ is the final result of a funtion.
     #+BEGIN_SRC haskell
     f x y z = h (subFunction x y z)
       where subFunction x y z = g x y z
       -- h is the tail call
     #+END_SRC

   - Tail recursion
     #+BEGIN_SRC haskell
     f x y z = f (x - 1) y z
     #+END_SRC
* Chapter 11
** What's a type and what's data?
   - Types are static and resolve at compile time.
   - Types are known before runtime, wheter through expicit declaration or type inference, and that's
     what makes them static types.

     type constructors -- compile-time

     -------------------- phase separation

     data constructors -- runtime
** Data constructors arities
   - Arity refers to the number of arguments a function or constructor takes.
   - A function that takes no arguments is called /nullary/, a contraction of "null" and "-ary".
   - Null means zero, "-ary" suffix means "of or pertaining to".
   - Data constructors which take no arguments are also called nullary. Such as True and False,
     are constants values at the term level.
   - Data constructors that take one argument are called unary
   - Data constructors that take more than one argument are called products.

   - All of the following are valid data declarations:
     #+BEGIN_SRC haskell
     data Example0 = Example0 deriving (Eq, Show)

     data Example1 = Example1 Int deriving (Eq, Show)

     data Example2 = Example2 String Int deriving (Eq, Show) -- product
     #+END_SRC
** newtype
   #+BEGIN_SRC haskell
   newtype Goats = Goats Int deriving (Eq, Show) -- Goat is really an Int.
   newtype Cows = Cows Int deriving (Eq, Show)

   tooManyGoats :: Goats -> Bool
   tooManyGoats (Goats n) = n > 42
   #+END_SRC

   - One key contrast between a newtype and a type alias is that you can define typeclass instances
     for newtypes that differ from the instances for their underlying type. You can't do that
     for type synonyms.

     #+BEGIN_SRC haskell
class TooMany a where
  tooMany :: a -> Bool
instance TooMany Int where
  tooMany n = n > 42
-- Basically Goats is an Int, and TooMany already has an Int instance, but with newtype we can
-- have different behaviour, We can't do this if its a type synonym.
newtype Goats = Goats Int deriving Show
instance TooMany Goats where
  tooMany (Goats n) = n > 43
     #+end_src
** Record syntax
   - Records in Haskell are products types with additional syntax to provide convenient accessors
     to fields within the record.
     #+BEGIN_SRC haskell
     -- simple product type
     data Person = MkPerson String Int deriving (Eq, Show)

     -- unpack the contents
     jm = MkPerson "Julie" 108
     ca = MkPerson "chris" 16

     namae :: Person -> String
     namae (MkPerson s _) = s

     -- Now with record syntax
     data Person = Person {name :: String, age :: Int} deriving (Eq, Show)
     di = Person "Diego" 25
     name di == "Diego"
     age di == 25
     -- :t name :: Person -> String
     -- :t age :: Person -> Int
     #+END_SRC
** Normal form
   Distributive property generalized:
   a * (b + c) -> (a * b) + (a * c)
** Constructing and deconstructing values
   #+BEGIN_SRC haskell
   data GuessWhat = Chickenbutt deriving (Eq, Show)
   data Id a = MkId a deriving (Eq, Show)
   data Product a b = Product a b deriving (Eq, Show)
   data Sum a b = First a | Second b deriving (Eq, Show)
   data RecordProduct a b = RecordProduct {pfirst :: a, psecond :: b} deriving (Eq, Show)

   newtype NumCow =
  NumCow Int
  deriving (Eq, Show)

newtype NumPig =
  NumPig Int
  deriving (Eq, Show)

data Farmhouse =
  Farmhouse NumCow NumPig
  deriving (Eq, Show)

type Farmhouse' = Product NumCow NumPig -- Farmhouse and Farmhouse' are the same

newtype NumSheep =
  NumSheep Int
  deriving (Eq, Show)

data BigFarmhouse =
  BigFarmhouse1 NumCow NumPig NumSheep
  deriving (Eq, Show)

type BigFarmhouse' =
  Product NumCow (Product NumPig NumSheep) -- BigFarmhouse and BigFarmhouse' are the same.

-- we can perform a similar trick with sum:

type Name = String
type Age = Int
type LovesMud = Bool
type PoundsOfWool = Int

data CowInfo =
  CowInfo Name Age
  deriving (Eq, Show)

data PigInfo =
  PigInfo Name Age LovesMud
  deriving (Eq, Show)

data SheepInfo =
  SheepInfo Name Age PoundsOfWool
  deriving (Eq, Show)

data Animal =
  Cow CowInfo
  | Pig PigInfo
  | Sheep SheepInfo
  deriving (Eq, Show)

-- Alternately
type Animal' =
  Sum CowInfo (Sum PigInfo SheepInfo)
--Sum First  |  Second
bess' = (PigInfo "Pig" 3 True)
bess = Second (First bess') :: Animal'

   #+END_SRC
** Deconstructing values
   #+BEGIN_SRC haskell
   -- Deconstruct data

newtype Name = Name String deriving Show
newtype Acres = Acres Int deriving Show

-- FarmerType is a Sum
data FarmerType = DairyFarmer
                | WheatFarmer
                | SoybeanFarmer
                deriving Show

-- Farmer is a plain ole product of
-- Name, Acres, and FarmerType

data Farmer =
  Farmer Name Acres FarmerType
  deriving Show

-- breaking up the data

isDairyFarmer :: Farmer -> Bool
isDairyFarmer (Farmer _ _ DairyFarmer) = True -- DairyFarmer is packed up inside
                                         --  our Farmer product type.
isDairyFarmer _ = False

-- Alternate formulation with a product that uses record syntax:
data FarmerRec =
  FarmerRec { name :: Name
            , acres :: Acres
            , farmerType :: FarmerType}
  deriving Show

isDairyFarmerRec :: FarmerRec -> Bool
isDairyFarmerRec farmer =
  case farmerType farmer of
    DairyFarmer -> True
    _ -> False

   #+END_SRC
** Accidental bottoms from records
   - Please do not do this:
     #+BEGIN_SRC haskell
     data Automobile = Null | Car {make :: String, model :: String, year :: Integer}

     -- better to split the product
     data Car = Car {make :: String, model :: String, year :: Integer} deriving (Eq, Show)

data Automobile = Null
                | Automobile Car
                deriving (Eq, Show)
     #+END_SRC

** Function type is exponential
   a -> b -> c
   (c ^ b) ^ a
   c ^ (b * a)
** Higher-kinded datatypes
   - Types can be generically polymorphic by taking type arguments, and can be applied at the
     type level:
     #+BEGIN_SRC haskell
     -- identical to (a,b,c,d)
data Silly a b c d =
  MkSilly a b c d deriving Show

-- :k Silly
-- Silly :: * -> * -> * -> * -> *

-- :k Silly Int
-- Silly Int :: * -> * -> * -> *

-- :k Silly Int String
-- Silly Int String :: * -> * -> *

-- :k Silly Int String Bool
-- Silly Int String Bool :: * -> *

-- :k Silly Int String Bool String
-- Silly Int String Bool String :: *

-- identical to (a,b,c,d)
-- :k (,,,)
-- (,,,) :: * -> * -> * -> * -> *

-- :k (Int, String, Bool, String)
-- (Int, String, Bool, String) :: *
     #+END_SRC

** Lists are polymorphic
   #+BEGIN_SRC haskell
   data [] a = [] | a : [a]

   f :: [] Integer
   f = [1]

   s :: [] String
   s = ["Hello"]

   -- List type without using an infix constructor:
   data List a = Nil | Cons a (List a)
   oneItem = (Cons "item" Nil)
   twoItems = (Cons "item2" oneItem)
   #+END_SRC
** Binary Tree
   #+BEGIN_SRC haskell
   data BinaryTree a = Leaf | Node (BinaryTree a) a (BinaryTree a) deriving (Eq, Ord, Show)
   #+END_SRC
** Inserting into trees
** As-patterns
   #+BEGIN_SRC haskell
   f :: Show a => (a, b) -> IO (a, b)
   f t@(a, _) = do
     print a
     return t
   #+END_SRC
** Definitions
   1. A datatype is how we declare and create data for our functions to receive as inputs.
   Datatype declarations begin with the keyword data. A datatype is made up of a type
   constructor and zero or more data constructors which
* Chapter 12
** Signaling adversity
   #+BEGIN_SRC haskell
   ifEvenAdd2 :: Integer -> Integer
   ifEvenAdd2 n = if even n then n+2 else ??? // what to return?

   // better this way
   ifEvenAdd2 :: Integer -> Maybe Integer
   ifEvenAdd2 n = if even n then Just (n+2) else Nothing
   #+END_SRC
